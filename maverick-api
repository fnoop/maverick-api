#!/usr/bin/env python

'''
Tornado server for maverick-api
Samuel Dudley
Feb 2018
https://github.com/goodrobots/maverick-api
'''
VERSION = "v0.1"

# TODO: setup tests and flake8

# std lib imports
import __future__
import logging
from logging.handlers import RotatingFileHandler
import os, json, sys, select, signal, threading
import time
import queue
from uuid import uuid4 # used to generate unique IDs
import datetime

# tornado imports
import tornado.web
from tornado import gen
from tornado.log import enable_pretty_logging

from concurrent.futures import ThreadPoolExecutor

# tornadoql imports
from tornadoql.graphql_handler import GQLHandler
from tornadoql.subscription_handler import GQLSubscriptionHandler

# schema imports
from api.schema import schema
from api.schema import UpdateStateMessage, UpdateVfrHudMessage
from api.schema import UpdatePoseStampedMessage, UpdateNavSatFixMessage
from api.schema import UpdateImuMessage
from api.schema import UpdateParameter

# ROS imports
import rospy
import mavros
import mavros.utils
from std_msgs.msg import String
from mavros_msgs.msg import State, VFR_HUD
from sensor_msgs.msg import NavSatFix, Imu
from geometry_msgs.msg import PoseStamped

# zeroconf placeholder
# from zeroconf import ServiceInfo, Zeroconf # advertise available websockets to browser

external_fn_queue = queue.Queue()
external_fn_executor = ThreadPoolExecutor(max_workers=1)

APP_ROOT = os.path.dirname(os.path.abspath(__file__))
APP_STATIC = os.path.join(APP_ROOT, 'static')
# TODO: group the settings and make configurable
SETTINGS = {
    'static_path': APP_STATIC,
    'sockets': [],
    'subscriptions': {}
}

# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphQLHandler(GQLHandler):
    @property
    def schema(self):
        return TornadoQL.schema
    
# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphQLSubscriptionHandler(GQLSubscriptionHandler):
    def initialize(self, opts):
        super(GraphQLSubscriptionHandler, self).initialize()
        self.opts = opts

    @property
    def schema(self):
        return TornadoQL.schema

    @property
    def sockets(self):
        return self.opts['sockets']

    @property
    def subscriptions(self):
        return self.opts['subscriptions'].get(self, {})

    @subscriptions.setter
    def subscriptions(self, subscriptions):
        self.opts['subscriptions'][self] = subscriptions
        
# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphiQLHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(os.path.join(APP_STATIC, 'graphiql.html'))

class SchemaHandler(tornado.web.RequestHandler):
    '''introspection of the api schema'''
    @tornado.web.asynchronous
    def get(self):
        introspection_dict = TornadoQL.schema.introspect()
        self.write(json.dumps(introspection_dict, indent=4, sort_keys=True))
        self.finish()

# Adapted from https://github.com/IlyaRadinsky/tornadoql under MIT license
class TornadoQL(tornado.web.Application):
    def __init__(self, config):
        # TODO: roll settings into config
        args = dict(opts=SETTINGS)
        handlers = [
            (r'/subscriptions', GraphQLSubscriptionHandler, args),
            (r'/graphql', GraphQLHandler),
            (r'/graphiql', GraphiQLHandler),
            (r'/schema', SchemaHandler)
        ]
        
        settings = dict(
            cookie_secret = config['APP_SECRET_KEY'],
            static_path = APP_STATIC,
            xsrf_cookies = False,
        )
        TornadoQL.schema = schema
        super(TornadoQL, self).__init__(handlers, **settings)

class ExternalFunctionCallback(object):
    '''runs functions from other threads asynchronously within the ioloop'''
    def __init__(self):
        tornado.ioloop.IOLoop.current().add_callback(self.watch_queue)
    
    def stop(self):
        external_fn_queue.put_nowait(None)

    @tornado.gen.coroutine
    def watch_queue(self):
        while True:
            ret = yield(external_fn_executor.submit(external_fn_queue.get, block=True))
            if ret:
                (callback, kwargs) = ret
                callback(**kwargs)
            else:
                break
            
def setup_logging(config):
    handler = RotatingFileHandler('tornado.log', mode='a', maxBytes=5*1024*1024, backupCount=2, encoding=None, delay=0)
    enable_pretty_logging()
    formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
    handler.setFormatter(formatter)
    access_log = logging.getLogger("tornado.access")
    app_log = logging.getLogger("tornado.application")
    gen_log = logging.getLogger("tornado.general")
    app_log.addHandler(handler)
    gen_log.addHandler(handler)
    access_log.addHandler(handler)
    # TODO: log level set by config
    app_log.setLevel(logging.DEBUG)
    gen_log.setLevel(logging.DEBUG)
    access_log.setLevel(logging.DEBUG)
    
def start_server(config):
    application = TornadoQL(config)
    server = tornado.httpserver.HTTPServer(application)
    server.listen(port = int(config['SERVER_PORT']), address = str(config['SERVER_INTERFACE']))
    if config['APP_DEBUG']:
        print("Starting Maverick-API server: {0}:{1}/{2}".format(config['SERVER_INTERFACE'], config['SERVER_PORT'], config['APP_PREFIX']))
    return server

def main(config):
    setup_logging(config)
    external_callback = ExternalFunctionCallback()
    server = start_server(config)
    tornado.ioloop.IOLoop.current().start()
    # this function blocks at this point until the server is asked to exit via request_server_stop()
    if config['APP_DEBUG']:
        print("Tornado finished")
    external_callback.stop()
    server.stop()

def request_server_stop(config):
    # TODO: close all websocket connections (required?)
    ioloop = tornado.ioloop.IOLoop.current()
    ioloop.add_callback(ioloop.stop)
    if config['APP_DEBUG']:
        print("Asked Tornado to exit")
    
class Server(object):
    def __init__(self, optsargs):
        self.exit = False
        (self.opts, self.args) = optsargs
        self.server_thread = None
        # TODO: fix this config mess... 
        self.config = Configuration(self.opts.configuration)
        self.config = self.config.get_config()
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        
        self.server_thread = threading.Thread(target=main, args = (self.config,))
        self.server_thread.daemon = True
        self.server_thread.start()
        self.main_loop()

    def main_loop(self):
        '''main loop of the api server'''
        # setup the connection to ROS
        self.connection = Connection()
        while not self.exit:
            time.sleep(1.0)
        print('Server finished')
        
    def process_connection_in(self):
        '''process data connection(s)'''
        pass
        
    def exit_gracefully(self, signum, frame):
        '''called on sigterm'''
        self.exit = True
        self.connection.shutdown()
        if self.server_thread:
            # attempt to shutdown the tornado server
            request_server_stop(self.config)
            self.server_thread.join(timeout=10)
            
class Connection(object):
    def __init__(self):
        self.connect()
        self.topics()
        self.params()
        self.listener()

    def connect(self):
        rospy.init_node('listener', anonymous=True, disable_signals=True)
        
    def shutdown(self):
        rospy.signal_shutdown('API Shutdown')
    
    def listener(self):
        rospy.Subscriber("/mavros/state", State, self.state_callback)
        rospy.Subscriber("/mavros/vfr_hud", VFR_HUD, self.vfr_hud_callback)
        rospy.Subscriber("/mavros/global_position/global", NavSatFix, self.nav_sat_fix_callback)
        rospy.Subscriber("/mavros/local_position/pose", PoseStamped, self.pose_stamped_callback)
        rospy.Subscriber("/mavros/imu/data", Imu, self.imu_callback)
    
    def topics(self):
        topics = rospy.get_published_topics()
        for topic in topics:
            print(topic)
            
    def params(self):
        # TODO: remove wildcard imports and support setting params
        # e.g. ret = param_set("SERIAL1_BAUD", 57)
        from mavros.utils import *
        from mavros.param import *
        import numbers
        
        mavros.set_namespace("mavros")
        param_received, param_list = param_get_all(False)
        print("Parameters received:", param_received)
        
        for param in param_list:
            kwargs = {'id':param.param_id,'value':param.param_value,'is_float':isinstance(param.param_value, numbers.Integral)}
            external_fn_queue.put_nowait((UpdateParameter().mutate, kwargs))
            # print param.param_value, type(param.param_value), param.param_id
    
    def state_callback(self, data):
        kwargs = {'seq':data.header.seq,'frame_id':data.header.frame_id,'guided':data.guided,
                  'nsecs':data.header.stamp.nsecs,'system_status':data.system_status,'secs':data.header.stamp.secs,
                  'connected':data.connected,'mode':data.mode,'armed':data.armed}
        external_fn_queue.put_nowait((UpdateStateMessage().mutate, kwargs))
        
    def vfr_hud_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'airspeed':data.airspeed, 'groundspeed':data.groundspeed, 'heading':data.heading,
                  'throttle':data.throttle, 'altitude':data.altitude, 'climb':data.climb}
        external_fn_queue.put_nowait((UpdateVfrHudMessage().mutate, kwargs))

    def nav_sat_fix_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'status_status':data.status.status, 'status_service':data.status.service, 'latitude':data.latitude, 'longitude':data.longitude,
                  'altitude':data.altitude, 'position_covariance_type':data.position_covariance_type}
        external_fn_queue.put_nowait((UpdateNavSatFixMessage().mutate, kwargs))

    def pose_stamped_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'pose_position_x':data.pose.position.x,  'pose_position_y':data.pose.position.y,  'pose_position_z':data.pose.position.z,
                  'pose_orientation_x':data.pose.orientation.x,  'pose_orientation_y':data.pose.orientation.y,  'pose_orientation_z':data.pose.orientation.z, 'pose_orientation_w':data.pose.orientation.w}
        external_fn_queue.put_nowait((UpdatePoseStampedMessage().mutate, kwargs))
    
    def imu_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'orientation_x':data.orientation.x, 'orientation_y':data.orientation.y, 'orientation_z':data.orientation.z, 'orientation_w':data.orientation.w,
                  'angular_velocity_x':data.angular_velocity.x, 'angular_velocity_y':data.angular_velocity.y, 'angular_velocity_z':data.angular_velocity.z,
                  'linear_acceleration_x':data.linear_acceleration.x, 'linear_acceleration_y':data.linear_acceleration.y, 'linear_acceleration_z':data.linear_acceleration.z}
        external_fn_queue.put_nowait((UpdateImuMessage().mutate, kwargs))

if __name__ == '__main__':
    from optparse import OptionParser
    from config import Configuration
    parser = OptionParser('maverick-api [options]')
    
    parser.add_option("--configuration", dest="configuration", type='str',
                      help="configuration file name", default="config.json")
    optsargs = parser.parse_args()
    (opts,args) = optsargs
    
    Server(optsargs)