#!/usr/bin/env python

'''
Tornado server for maverick-api
Samuel Dudley
Feb 2018
https://github.com/goodrobots/maverick-api
'''
VERSION = "v0.1"

# TODO: setup tests and flake8

# std lib imports
import __future__
import logging
from logging.handlers import RotatingFileHandler
import os, json, sys, select, signal, threading
import time
import queue
from uuid import uuid4 # used to generate unique IDs

# tornado imports
import tornado.web
from tornado import gen
from tornado.log import enable_pretty_logging

from concurrent.futures import ThreadPoolExecutor

# tornadoql imports
from tornadoql.graphql_handler import GQLHandler
from tornadoql.subscription_handler import GQLSubscriptionHandler

# schema imports
from api.schema import schema
from api.schema import UpdateStateMessage, UpdateVFRHUDMessage
from api.schema import UpdatePoseStampedMessage, UpdateNavSatFixMessage
from api.schema import UpdateImuMessage

# ROS imports
import rospy
import mavros
import mavros.utils
from std_msgs.msg import String
from mavros_msgs.msg import State, VFR_HUD
from sensor_msgs.msg import NavSatFix, Imu
from geometry_msgs.msg import PoseStamped

# zeroconf placeholder
# from zeroconf import ServiceInfo, Zeroconf # advertise available websockets to browser

que = queue.Queue()
executor = ThreadPoolExecutor()

APP_ROOT = os.path.dirname(os.path.abspath(__file__))
APP_STATIC = os.path.join(APP_ROOT, 'static')
# TODO: group the settings and make configurable
SETTINGS = {
    'static_path': APP_STATIC,
    'sockets': [],
    'subscriptions': {}
}

# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphQLHandler(GQLHandler):
    @property
    def schema(self):
        return TornadoQL.schema
    
# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphQLSubscriptionHandler(GQLSubscriptionHandler):

    def initialize(self, opts):
        super(GraphQLSubscriptionHandler, self).initialize()
        self.opts = opts

    @property
    def schema(self):
        return TornadoQL.schema

    @property
    def sockets(self):
        return self.opts['sockets']

    @property
    def subscriptions(self):
        return self.opts['subscriptions'].get(self, {})

    @subscriptions.setter
    def subscriptions(self, subscriptions):
        self.opts['subscriptions'][self] = subscriptions
        
# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphiQLHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(os.path.join(APP_STATIC, 'graphiql.html'))

class SchemaHandler(tornado.web.RequestHandler):
    '''introspection of the api schema'''
    
    @tornado.web.asynchronous
    def get(self):
        introspection_dict = TornadoQL.schema.introspect()
        self.write(json.dumps(introspection_dict, indent=4, sort_keys=True))
        self.finish()

# Adapted from https://github.com/IlyaRadinsky/tornadoql under MIT license
class TornadoQL(tornado.web.Application):
    def __init__(self, config):
        # TODO: roll settings into config
        args = dict(opts=SETTINGS)
        handlers = [
            (r'/subscriptions', GraphQLSubscriptionHandler, args),
            (r'/graphql', GraphQLHandler),
            (r'/graphiql', GraphiQLHandler),
            (r'/schema', SchemaHandler)
        ]
        
        settings = dict(
            cookie_secret = config['APP_SECRET_KEY'],
            static_path = APP_STATIC,
            xsrf_cookies = False,
        )
        TornadoQL.schema = schema
        super(TornadoQL, self).__init__(handlers, **settings)

class Client():
    def __init__(self):
        pass

    @tornado.gen.coroutine
    def watch_queue(self):
        while True: # TODO: exit this loop on server shutdown
            (msg,data)= (yield executor.submit(que.get))
            if msg == 'vfr':
                kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                         'airspeed':data.airspeed, 'groundspeed':data.groundspeed, 'heading':data.heading,
                         'throttle':data.throttle, 'altitude':data.altitude, 'climb':data.climb}
                # yield executor.submit(UpdateVFRHUDMessage().mutate, **kwargs)
                UpdateVFRHUDMessage().mutate(**kwargs)
                # print 'vfr'

                
            elif msg == 'state':
                kwargs = {'seq':data.header.seq,'frame_id':data.header.frame_id,'guided':data.guided,
                         'nsecs':data.header.stamp.nsecs,'system_status':data.system_status,'secs':data.header.stamp.secs,
                         'connected':data.connected,'mode':data.mode,'armed':data.armed}
                # yield executor.submit(UpdateStateMessage().mutate, **kwargs)
                UpdateStateMessage().mutate(**kwargs)
                # print 'state'
                
            elif msg == 'nav':
                kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                         'status_status':data.status.status, 'status_service':data.status.service, 'latitude':data.latitude, 'longitude':data.longitude,
                         'altitude':data.altitude, 'position_covariance_type':data.position_covariance_type}
                # yield executor.submit(UpdateNavSatFixMessage().mutate, **kwargs)
                UpdateNavSatFixMessage().mutate(**kwargs)
                # print 'nav'
            
            elif msg == 'imu':
                kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                             'orientation_x':data.orientation.x, 'orientation_y':data.orientation.y, 'orientation_z':data.orientation.z, 'orientation_w':data.orientation.w,
                             'angular_velocity_x':data.angular_velocity.x, 'angular_velocity_y':data.angular_velocity.y, 'angular_velocity_z':data.angular_velocity.z,
                             'linear_acceleration_x':data.linear_acceleration.x, 'linear_acceleration_y':data.linear_acceleration.y, 'linear_acceleration_z':data.linear_acceleration.z}
                # yield executor.submit(UpdateImuMessage().mutate, **kwargs)
                UpdateImuMessage().mutate(**kwargs)
                # print 'imu'

            elif msg == 'pose':
                kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                             'pose_position_x':data.pose.position.x,  'pose_position_y':data.pose.position.y,  'pose_position_z':data.pose.position.z,
                             'pose_orientation_x':data.pose.orientation.x,  'pose_orientation_y':data.pose.orientation.y,  'pose_orientation_z':data.pose.orientation.z, 'pose_orientation_w':data.pose.orientation.w}
                # yield executor.submit(UpdatePoseStampedMessage().mutate, **kwargs)
                UpdatePoseStampedMessage().mutate(**kwargs)
                # print 'pose'

            # else:
            #     print 'none'
                

def start_app(config):
    handler = RotatingFileHandler('tornado.log', mode='a', maxBytes=5*1024*1024, backupCount=2, encoding=None, delay=0)
    enable_pretty_logging()
    formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
    handler.setFormatter(formatter)
    access_log = logging.getLogger("tornado.access")
    app_log = logging.getLogger("tornado.application")
    gen_log = logging.getLogger("tornado.general")
    app_log.addHandler(handler)
    gen_log.addHandler(handler)
    access_log.addHandler(handler)
    app_log.setLevel(logging.DEBUG)
    gen_log.setLevel(logging.DEBUG)
    access_log.setLevel(logging.DEBUG)
    
    application = TornadoQL(config)
    server = tornado.httpserver.HTTPServer(application)
    server.listen(port = int(config['SERVER_PORT']), address = str(config['SERVER_INTERFACE']))
    if config['APP_DEBUG']:
        print("Starting Maverick-API server: {0}:{1}/{2}".format(config['SERVER_INTERFACE'], config['SERVER_PORT'], config['APP_PREFIX']))
    return server

def stop_tornado(config):
    # TODO: close all websocket connections (required?)
    ioloop = tornado.ioloop.IOLoop.current()
    ioloop.add_callback(ioloop.stop)
    if config['APP_DEBUG']:
        print("Asked Tornado to exit")

def main(config):
    server = start_app(config=config)
    
    client = Client()
    # Watch the queue for when new items show up
    tornado.ioloop.IOLoop.current().add_callback(client.watch_queue)
    
    
    tornado.ioloop.IOLoop.current().start()
    if config['APP_DEBUG']:
        print("Tornado finished")
    server.stop()
    
     
class Server(object):
    def __init__(self, optsargs):
        self.exit = False
        (self.opts, self.args) = optsargs
        self.server_thread = None
        # TODO: fix this config mess... 
        self.config = Configuration(self.opts.configuration)
        self.config = self.config.get_config()
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        
        self.server_thread = threading.Thread(target=main, args = (self.config,))
        self.server_thread.daemon = True
        self.server_thread.start()
        self.main_loop()

    def main_loop(self):
        '''main loop of the api server'''
        # setup the connection to ROS
        self.connection = Connection()
        while not self.exit:
            time.sleep(1.0)
        print('Server finished')
        
    def process_connection_in(self):
        '''process data connection(s)'''
        pass
        
    def exit_gracefully(self, signum, frame):
        '''called on sigterm'''
        self.exit = True
        if self.server_thread:
            # attempt to shutdown the tornado server
            stop_tornado(self.config)
            self.server_thread.join(timeout=10)
            
class Connection(object):
    def __init__(self):
        self.connect()
        self.topics()
        self.listener()

    def connect(self):
        rospy.init_node('listener', anonymous=True)
    
    def listener(self):
        rospy.Subscriber("/mavros/state", State, self.state_callback)
        rospy.Subscriber("/mavros/vfr_hud", VFR_HUD, self.vfr_hud_callback)
        rospy.Subscriber("/mavros/global_position/global", NavSatFix, self.nav_sat_fix_callback)
        rospy.Subscriber("/mavros/local_position/pose", PoseStamped, self.pose_stamped_callback)
        rospy.Subscriber("/mavros/imu/data", Imu, self.imu_callback)
    
    def topics(self):
        topics = rospy.get_published_topics()
        for topic in topics:
            print(topic)
    
    def state_callback(self, data):
        # kwargs = {'seq':data.header.seq,'frame_id':data.header.frame_id,'guided':data.guided,
        #  'nsecs':data.header.stamp.nsecs,'system_status':data.system_status,'secs':data.header.stamp.secs,
        #  'connected':data.connected,'mode':data.mode,'armed':data.armed}
        # UpdateStateMessage().mutate(**kwargs)
        que.put_nowait(('state',data))
        
    def vfr_hud_callback(self, data):
        # kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
        #  'airspeed':data.airspeed, 'groundspeed':data.groundspeed, 'heading':data.heading,
        #  'throttle':data.throttle, 'altitude':data.altitude, 'climb':data.climb}
        # UpdateVFRHUDMessage().mutate(**kwargs)
        que.put_nowait(('vfr',data))
        
    
    def nav_sat_fix_callback(self, data):
        # kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
        #  'status_status':data.status.status, 'status_service':data.status.service, 'latitude':data.latitude, 'longitude':data.longitude,
        #  'altitude':data.altitude, 'position_covariance_type':data.position_covariance_type}
        # UpdateNavSatFixMessage().mutate(**kwargs)
        que.put_nowait(('nav',data))
        

    def pose_stamped_callback(self, data):
        # kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
        #      'pose_position_x':data.pose.position.x,  'pose_position_y':data.pose.position.y,  'pose_position_z':data.pose.position.z,
        #      'pose_orientation_x':data.pose.orientation.x,  'pose_orientation_y':data.pose.orientation.y,  'pose_orientation_z':data.pose.orientation.z, 'pose_orientation_w':data.pose.orientation.w}
        # UpdatePoseStampedMessage().mutate(**kwargs)
        que.put_nowait(('pose',data))
    
    def imu_callback(self, data):
        # kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
        #      'orientation_x':data.orientation.x, 'orientation_y':data.orientation.y, 'orientation_z':data.orientation.z, 'orientation_w':data.orientation.w,
        #      'angular_velocity_x':data.angular_velocity.x, 'angular_velocity_y':data.angular_velocity.y, 'angular_velocity_z':data.angular_velocity.z,
        #      'linear_acceleration_x':data.linear_acceleration.x, 'linear_acceleration_y':data.linear_acceleration.y, 'linear_acceleration_z':data.linear_acceleration.z}
        # UpdateImuMessage().mutate(**kwargs)
        que.put_nowait(('imu',data))

if __name__ == '__main__':
    from optparse import OptionParser
    from config import Configuration
    parser = OptionParser('maverick-api [options]')
    
    parser.add_option("--configuration", dest="configuration", type='str',
                      help="configuration file name", default="config.json")
    optsargs = parser.parse_args()
    (opts,args) = optsargs
    
    Server(optsargs)