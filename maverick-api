#!/usr/bin/env python

'''
Tornado server for maverick-api
Samuel Dudley
Feb 2018
https://github.com/goodrobots/maverick-api
'''
VERSION = "v0.1"

# TODO: setup tests and flake8

# std lib imports
import __future__
import logging
from logging.handlers import RotatingFileHandler
import os, json, sys, select, signal, threading
import time
import queue
from uuid import uuid4 # used to generate unique IDs
import datetime

# tornado imports
import tornado.web
from tornado import gen
from tornado.log import enable_pretty_logging
from concurrent.futures import ThreadPoolExecutor

# tornadoql imports
from tornadoql.graphql_handler import GQLHandler
from tornadoql.subscription_handler import GQLSubscriptionHandler

# schema imports
from api.schema import schema
from api.schema import UpdateStateMessage, UpdateVfrHudMessage
from api.schema import UpdatePoseStampedMessage, UpdateNavSatFixMessage
from api.schema import UpdateImuMessage
from api.schema import UpdateParameter
from api.schema import UpdateWaypoint
from api.schema import UpdateStatusTextMessage

# utility imports
from util.common import merge_two_dicts
from util.mavlink import get_meta_string

# ROS imports
import rospy
import mavros
import mavros.utils
from std_msgs.msg import String
from rosgraph_msgs.msg import Log
from mavros_msgs.msg import State, VFR_HUD
from mavros_msgs.srv import StreamRate, StreamRateRequest
from sensor_msgs.msg import NavSatFix, Imu
from geometry_msgs.msg import PoseStamped
from mavros_maverick.msg import Param # callback msg on param change
from mavros_maverick.srv import VehicleInfo
from mavros.param import param_ret_value
from mavros import mission

# PyMAVLink imports
from pymavlink import mavutil

# SQLAlchemy imports
from sqlalchemy import *
from sqlalchemy.orm import (scoped_session, sessionmaker, relationship, backref)
from sqlalchemy.ext.declarative import declarative_base

# zeroconf placeholder
# from zeroconf import ServiceInfo, Zeroconf # advertise available websockets to browser

external_fn_queue = queue.Queue()
external_fn_executor = ThreadPoolExecutor(max_workers=1)

# setup logging
handler = RotatingFileHandler('tornado.log', mode='a', maxBytes=1*1024*1024, backupCount=2, encoding=None, delay=0)
enable_pretty_logging()
formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
handler.setFormatter(formatter)
access_log = logging.getLogger("tornado.access")
app_log = logging.getLogger("tornado.application")
gen_log = logging.getLogger("tornado.general")
app_log.addHandler(handler)
gen_log.addHandler(handler)
access_log.addHandler(handler)
# TODO: log level set by config
app_log.setLevel(logging.DEBUG)
gen_log.setLevel(logging.DEBUG)
access_log.setLevel(logging.DEBUG)

APP_ROOT = os.path.dirname(os.path.abspath(__file__))
APP_STATIC = os.path.join(APP_ROOT, 'static')
# TODO: group the settings and make configurable
SETTINGS = {
    'static_path': APP_STATIC,
    'sockets': [],
    'subscriptions': {}
}

# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphQLHandler(GQLHandler):
    @property
    def schema(self):
        return TornadoQL.schema
    
# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphQLSubscriptionHandler(GQLSubscriptionHandler):
    def initialize(self, opts):
        super(GraphQLSubscriptionHandler, self).initialize()
        self.opts = opts

    @property
    def schema(self):
        return TornadoQL.schema

    @property
    def sockets(self):
        return self.opts['sockets']

    @property
    def subscriptions(self):
        return self.opts['subscriptions'].get(self, {})

    @subscriptions.setter
    def subscriptions(self, subscriptions):
        self.opts['subscriptions'][self] = subscriptions
        
# Taken from https://github.com/IlyaRadinsky/tornadoql under MIT license
class GraphiQLHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(os.path.join(APP_STATIC, 'graphiql.html'))

class SchemaHandler(tornado.web.RequestHandler):
    '''introspection of the api schema'''
    @tornado.web.asynchronous
    def get(self):
        introspection_dict = TornadoQL.schema.introspect()
        self.write(json.dumps(introspection_dict, indent=4, sort_keys=True))
        self.finish()

# Adapted from https://github.com/IlyaRadinsky/tornadoql under MIT license
class TornadoQL(tornado.web.Application):
    def __init__(self, config):
        # TODO: roll settings into config
        args = dict(opts=SETTINGS)
        handlers = [
            (r'/subscriptions', GraphQLSubscriptionHandler, args),
            (r'/graphql', GraphQLHandler),
            (r'/graphiql', GraphiQLHandler),
            (r'/schema', SchemaHandler)
        ]
        
        settings = dict(
            cookie_secret = config['APP_SECRET_KEY'],
            static_path = APP_STATIC,
            xsrf_cookies = False,
        )
        TornadoQL.schema = schema
        super(TornadoQL, self).__init__(handlers, **settings)
            
def add_ioloop_callback(method, **kwargs):
    tornado.ioloop.IOLoop.current().add_callback(method, **kwargs)
    
def start_server(config):
    application = TornadoQL(config)
    server = tornado.httpserver.HTTPServer(application)
    server.listen(port = int(config['SERVER_PORT']), address = str(config['SERVER_INTERFACE']))
    if config['APP_DEBUG']:
        app_log.debug("Starting Maverick-API server: {0}:{1}/{2}".format(config['SERVER_INTERFACE'], config['SERVER_PORT'], config['APP_PREFIX']))
    return server

def main(config):
    # external_callback = ExternalFunctionCallback()
    server = start_server(config)
    tornado.ioloop.IOLoop.current().start()
    # this function blocks at this point until the server is asked to exit via request_server_stop()
    app_log.debug("Tornado finished")
    # external_callback.stop()
    server.stop()

def request_server_stop(config):
    # TODO: close all websocket connections (required?)
    ioloop = tornado.ioloop.IOLoop.current()
    ioloop.add_callback(ioloop.stop)
    app_log.debug("Asked Tornado to exit")
    
class Server(object):
    def __init__(self, optsargs):
        self.exit = False
        (self.opts, self.args) = optsargs
        self.server_thread = None
        self.mavros_connection = None
        self.mavlink_connection = None
        
        # TODO: fix this config mess... 
        self.config = Configuration(self.opts.configuration)
        self.config = self.config.get_config()
        signal.signal(signal.SIGINT, self.exit_gracefully)
        signal.signal(signal.SIGTERM, self.exit_gracefully)
        
        self.server_thread = threading.Thread(target=main, args = (self.config,))
        self.server_thread.daemon = True
        self.server_thread.start()
        # setup the MAVLink connection
        # self.mavlink_connection = MAVLINKConnection()
        # setup the connection to ROS
        self.mavros_connection = MAVROSConnection(self.config)
        #self.mavlog_connection = MAVLOGConnection(self.config)
        # self.server_thread.join()
        self.main_loop()

    def main_loop(self):
        '''main loop of the api server'''

        while not self.exit:
            time.sleep(1.0)
        app_log.info('Server finished')
        
    def exit_gracefully(self, signum, frame):
        '''called on sigterm'''
        self.exit = True
        if self.mavros_connection:
            self.mavros_connection.shutdown()
        if self.mavlink_connection:
            self.mavlink_connection.shutdown()
        if self.server_thread:
            # attempt to shutdown the tornado server
            request_server_stop(self.config)
            self.server_thread.join(timeout=10)

class MAVROSConnection(object):
    def __init__(self, config):
        # Attributes
        self.config = config
        self.info = None
        self.meta_string = '' # meta string used to load the correct params
        self.waypoints = None
        # Methods
        self.connect()
        # self.topics()
        self.streams()
        self.vehicle_info() # work out the autopilot and vehicle type
        self.params(meta_string = self.meta_string) # this is called from the IOloop once we know the vehicle type
        self.mission_waypoints()
        self.listener()

    def connect(self):
        rospy.init_node('listener', anonymous=True, disable_signals=True)
        mavros.set_namespace("mavros")

    def shutdown(self):
        rospy.signal_shutdown('API Shutdown')
    
    def streams(self):
        # Create ROS service definition for StreamRate
        set_rate = rospy.ServiceProxy(mavros.get_topic('set_stream_rate'), StreamRate)
        # Define function to do the stream request
        def do_set_rate(stream_rate, stream_id):
            if stream_rate is not None:
                try:
                    set_rate(stream_id=stream_id, message_rate=stream_rate, on_off=(stream_rate != 0))
                    app_log.debug('Set stream {} rate {}'.format(stream_id, stream_rate))
                except rospy.ServiceException as ex:
                    fault(ex)
        # Request streams
        """
        stream_rates = {
            'STREAM_RAW_SENSORS': 5,
            'STREAM_EXTENDED_STATUS': 5,
            'STREAM_RC_CHANNELS': 5,
            'STREAM_RAW_CONTROLLER': 5,
            'STREAM_POSITION': 10, # POSE
            'STREAM_EXTRA1': 10, # IMU
            'STREAM_EXTRA2': 5, # VFR_HUD
            'STREAM_EXTRA3': 1
        }
        """
        stream_rates = {
            'STREAM_RAW_SENSORS': 1,
            'STREAM_EXTENDED_STATUS': 1,
            'STREAM_RC_CHANNELS': 1,
            'STREAM_RAW_CONTROLLER': 1,
            'STREAM_POSITION': 1, # POSE
            'STREAM_EXTRA1': 1, # IMU
            'STREAM_EXTRA2': 1, # VFR_HUD
            'STREAM_EXTRA3': 1
        }
        for stream,rate in stream_rates.items():
            do_set_rate(rate, getattr(StreamRateRequest, stream))
            
    def vehicle_info(self):
        # Create ROS service definition for VehicleInfo
        get_vehicle_info = rospy.ServiceProxy(mavros.get_topic('get_vehicle_info'), VehicleInfo)
        try:
            self.info = get_vehicle_info()
            self.meta_string = get_meta_string(self.info)
            app_log.debug(self.info)
            app_log.info(self.meta_string)
        except rospy.ServiceException as ex:
            app_log.error('An error occurred while retrieving vehicle info via ROS: {0}'.format(ex))

    def mission_waypoints(self):
        self.waypoints = mission.pull()
        mission.subscribe_waypoints(self.mission_callback)

    def listener(self):
        rospy.Subscriber("/mavros/state", State, self.state_callback)
        rospy.Subscriber("/mavros/vfr_hud", VFR_HUD, self.vfr_hud_callback)
        rospy.Subscriber("/mavros/global_position/global", NavSatFix, self.nav_sat_fix_callback)
        rospy.Subscriber("/mavros/local_position/pose", PoseStamped, self.pose_stamped_callback)
        rospy.Subscriber("/mavros/imu/data", Imu, self.imu_callback)
        rospy.Subscriber("/mavros/param_value", Param, self.param_callback)
        rospy.Subscriber('/rosout', Log, self.statustext_callback)
    
    def topics(self):
        topics = rospy.get_published_topics()
        for topic in topics:
            app_log.info(topic)
            
    def params(self, meta_string = 'ArduCopter'):
        # TODO: make vehicle dynamic and chosse between px4 and ardupilot
        from param.parse_param_xml import get_param_meta
        from api.schema import Parameters
        from mavros.param import param_get_all
        Parameters.callback = self.param_set_callback
        param_received, param_list = param_get_all(False)
        app_log.debug('Parameters received: {0}'.format(param_received))
                
        param_meta_vehicle = {}
        for param in param_list:
            kwargs = {'id':param.param_id,'value':param.param_value}
            # external_fn_queue.put_nowait((UpdateParameter().mutate, kwargs))
            add_ioloop_callback(UpdateParameter().mutate, **kwargs)
            
            param_meta_vehicle[param.param_id] = {'group':param.param_id.split('_')[0].strip().rstrip('_').upper()}
            app_log.debug('param get {0}:{1}  {2}'.format(param.param_id, param.param_value, type(param.param_value)))
        
        # TODO: handle IOError when mavlink-router is not connected to the AP but mavros is running
        
        if self.config['APP_DEBUG']:
            start_time = time.time()
        app_log.debug('starting parameter meta fetch')
        param_meta_server = get_param_meta(meta_string)
        app_log.debug('finished parameter meta fetch')
        if self.config['APP_DEBUG']:
            app_log.debug('parameter meta fetch took {0}s'.format(time.time() - start_time))
        Parameters.meta = merge_two_dicts(param_meta_vehicle, param_meta_server)
                
    def param_set_callback(self, param_data):
        from api.schema import Parameters
        # TODO:
        # write unit test
        # clean up logic
        from mavros.param import param_set
        
        mavros.set_namespace("mavros")
        ret = param_set(param_data['id'].encode('ascii','ignore'), float(param_data['value']))
        # if ret == param_value:
        #     # param set worked
        #     pass
        # else:
        #     # param set failed
        #     pass
        
        # # check to see if the set value matches the provided value
        # ret_param = param_get(param_data['id'])
        app_log.debug('param set {0}:{1}  {2}'.format(param_data['id'], param_data['value'], ret))
        # app_log.debug('{0}'.format(ret_param))
        return ret
        
    def state_callback(self, data):
        kwargs = {'seq':data.header.seq,'frame_id':data.header.frame_id,'guided':data.guided,
                  'nsecs':data.header.stamp.nsecs,'system_status':data.system_status,'secs':data.header.stamp.secs,
                  'connected':data.connected,'mode':data.mode,'armed':data.armed}
        tornado.ioloop.IOLoop.current().add_callback(UpdateStateMessage().mutate, **kwargs)

    def vfr_hud_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'airspeed':data.airspeed, 'groundspeed':data.groundspeed, 'heading':data.heading,
                  'throttle':data.throttle, 'altitude':data.altitude, 'climb':data.climb}
        tornado.ioloop.IOLoop.current().add_callback(UpdateVfrHudMessage().mutate, **kwargs)

    def nav_sat_fix_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'status_status':data.status.status, 'status_service':data.status.service, 'latitude':data.latitude, 'longitude':data.longitude,
                  'altitude':data.altitude, 'position_covariance_type':data.position_covariance_type}
        tornado.ioloop.IOLoop.current().add_callback(UpdateNavSatFixMessage().mutate, **kwargs)

    def pose_stamped_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'pose_position_x':data.pose.position.x,  'pose_position_y':data.pose.position.y,  'pose_position_z':data.pose.position.z,
                  'pose_orientation_x':data.pose.orientation.x,  'pose_orientation_y':data.pose.orientation.y,  'pose_orientation_z':data.pose.orientation.z,
                  'pose_orientation_w':data.pose.orientation.w}
        tornado.ioloop.IOLoop.current().add_callback(UpdatePoseStampedMessage().mutate, **kwargs)

    def imu_callback(self, data):
        kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id,
                  'orientation_x':data.orientation.x, 'orientation_y':data.orientation.y, 'orientation_z':data.orientation.z, 'orientation_w':data.orientation.w,
                  'angular_velocity_x':data.angular_velocity.x, 'angular_velocity_y':data.angular_velocity.y, 'angular_velocity_z':data.angular_velocity.z,
                  'linear_acceleration_x':data.linear_acceleration.x, 'linear_acceleration_y':data.linear_acceleration.y, 'linear_acceleration_z':data.linear_acceleration.z}
        tornado.ioloop.IOLoop.current().add_callback(UpdateImuMessage().mutate, **kwargs)

    def param_callback(self, data):
        # app_log.debug('param callback data: {0}  value type: {1} '.format(data, type(data.value)))
        kwargs = {'id':data.param_id,'value':param_ret_value(data)}
        tornado.ioloop.IOLoop.current().add_callback(UpdateParameter().mutate, **kwargs)

    def mission_callback(self, data):
        for seq, waypoint in enumerate(data.waypoints):
            kwargs = {'seq': seq, 'frame': waypoint.frame, 'command': waypoint.command, 'is_current': waypoint.is_current, 'autocontinue': waypoint.autocontinue,
                'param1': waypoint.param1, 'param2': waypoint.param2, 'param3': waypoint.param3, 'param4': waypoint.param4, 'latitude': waypoint.x_lat, 'longitude': waypoint.y_long,
                'altitude': waypoint.z_alt}
            tornado.ioloop.IOLoop.current().add_callback(UpdateWaypoint().mutate, **kwargs)

    def statustext_callback(self, data):
        if data.name == '/mavros':
            app_log.debug('statustext: {0}:{1}'.format(data.level, data.msg))
            kwargs = {'seq':data.header.seq, 'secs':data.header.stamp.secs, 'nsecs':data.header.stamp.nsecs, 'frame_id':data.header.frame_id, 'level':data.level, 'message':data.msg}
            tornado.ioloop.IOLoop.current().add_callback(UpdateStatusTextMessage().mutate, **kwargs)

"""
class MAVLOGConnection(object):
    def __init__(self, config):
        # Attributes
        self.config = config
        self.info = None
        self.connect()

    def connect(self):
        self.engine = create_engine('sqlite://///srv/maverick/data/analysis/mavlog-meta.db', convert_unicode=True)
        self.db_session = scoped_session(sessionmaker(autocommit=False, autoflush=False, bind=self.engine))
""" 


class Connection(object):
    def __init__(self, connection):
        self.control_connection = connection # a MAVLink connection
        self.control_link = self.control_connection.mav

class MAVLINKConnection(object):
    def __init__(self, connection_str = 'tcp:127.0.0.1:5780'):
        import threading
        self.exit = False
        try:
            self.connection = Connection(mavutil.mavlink_connection(connection_str))
            self.connection.control_connection.message_hooks.append(self.handle_msg)
        except Exception as e:
            app_log.error("Failed to connect to {0} : {1})".format(connection_str, e))
            # TODO: treat this as a stop condition?
            return
        
        self.autopilot_string = ''
        self.vehicle_string = ''
        self.params_updated = None
        
        self.main_thread = threading.Thread(target=self.main)
        self.main_thread.daemon = True
        self.main_thread.start()
        
    def shutdown(self):
        self.exit = True
    
    def process_connection_in(self):
        '''receive MAVLink messages'''
        try:
            inputready,outputready,exceptready = select.select([self.connection.control_connection.port],[],[],0.1)
            # block for 0.1 sec if there is nothing on the connection
            # otherwise we just dive right in...
            for s in inputready: 
                self.connection.control_connection.recv_msg()
            # mavlink buffer is never getting cleared
            # force clear the buffer to avoid memory leak
            if self.connection.control_connection.mav.buf_len() == 0 and self.connection.control_connection.mav.buf_index != 0:
                self.connection.control_connection.mav.buf = bytearray()
                self.connection.control_connection.mav.buf_index = 0
        except select.error:
            pass
    
    def main(self):
        while not self.exit:
            self.process_connection_in() # any down time (max 0.1 sec) occurs here
    
    def start_param_update(self, vehicle, force = False):
        if (not self.params_updated or force):
            pass
            
    
    def set_autopilot_string(self, msg):
        self.autopilot_string = mavutil.mavlink.enums['MAV_AUTOPILOT'][msg.autopilot].description
        
    def set_vehicle_string(self, msg):
        self.vehicle_string = mavutil.mavlink.enums['MAV_TYPE'][msg.type].description
    
    def handle_msg(self, con, msg):
        '''callback for received MAVLink messages''' 
        src_system = msg.get_srcSystem()
        src_component = msg.get_srcComponent()
        # if msg.get_type() == 'HEARTBEAT':
        #     app_log.debug((src_system, src_component))
        #     app_log.debug(msg)

        if src_system == 1:
            if msg.get_type() == 'HEARTBEAT':
                meta_string = get_meta_string(msg)
            else:
                # message type not handleded 
                pass
    
    

if __name__ == '__main__':
    from optparse import OptionParser
    from config import Configuration
    parser = OptionParser('maverick-api [options]')
    
    parser.add_option("--configuration", dest="configuration", type='str',
                      help="configuration file name", default="config.json")
    optsargs = parser.parse_args()
    (opts,args) = optsargs
    
    Server(optsargs)